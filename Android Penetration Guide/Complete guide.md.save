# README — Android Penetration Test (Exam / Lab Playbook)

**Audience:** CEH / pentest student preparing for a supervised Android lab (Android 11 / 12; brands: Tecno, Infinix, Oppo, Pixel).
**Scope:** Single initial physical access to target phone (one-time touch at start), isolated lab network, full authorized testing, demonstrate methods to obtain remote/live access, collect authorized evidence, and restore device.
**Style:** Practical, step-by-step conceptual guide from a professional pentester’s point of view. No destructive instructions — everything framed for a permissioned lab.

---

## Quick summary (one-liner)

You get one physical interaction at the start. Use that first touch to **image the device**, **isolate it**, and **set up the one-time foothold** (ADB / trusted test app / certificates) so you can continue all further testing remotely from your lab host. If you cannot change settings, perform maximal passive & static reconnaissance and exploit allowed vectors (exported components, user-installed app flows, network flaws). Document everything.

---

## Table of contents

1. Lab rules & pre-conditions
2. What to bring & host pre-setup
3. One-time physical touch — checklist (what to do immediately)
4. Initial verification & imaging (forensics-first)
5. Network isolation & baseline captures
6. Core workflows (recon → analysis → access → persistence → cleanup)
7. Tools (free, alternate free, commercial/premium) — what they do & when to use
8. If Developer Options / USB Debugging is OFF — realistic options
9. Reboot, power-off, and persistence realities (what works, what doesn’t)
10. What you can/can’t access (permissions, root, encryption)
11. Data collection, evidence & reporting (deliverables)
12. Cleanup & restore checklist
13. Practical pentester tips & exam-winning behaviours
14. 60-second exam starter checklist (cheat-sheet)
15. Appendix: example test plan & findings structure

---

## 1 — Lab rules & pre-conditions (always confirm)

* Confirm written authorization and scope (signed). This must be the first step.
* Confirm allowed actions (e.g., allowed to enable Developer Options, allowed to install test APKs, allowed to root or not). Get a list of **prohibited actions** in writing.
* Confirm device network is isolated / use a lab VLAN.
* Confirm what evidence (screenshots, logs, packet captures) lab expects and retention rules.

---

## 2 — What to bring & host pre-setup

**Bring (digital & physical):**

* Signed authorization document (printed).
* Laptop/VM with preinstalled core tools (see Tools section).
* Backup media (external drive) or network storage for image backups.
* USB-A/USB-C cable compatible with device.
* Paper & pen for serial numbers, timestamps, and signatures.

**Host pre-setup (do BEFORE exam):**

* Attacker host (Kali/Ubuntu/Windows VM) with core tools installed and tested on emulator.
* Isolated lab network (no internet or strict egress rules). Assign static IPs for host and device if possible.
* Emulators (Android Studio / Genymotion) with same Android versions for practice.
* Evidence/report templates ready.

---

## 3 — One-time physical touch — mandatory immediate actions (do these first)

When you get the phone for the single physical touch, do these in sequence. They are critical — they preserve your evidence and enable further testing.

1. **Identify & document**

   * Photograph the device (front, back, serial/IMEI, model).
   * Note Android version, security patch, build number, and carrier info (if shown).
   * Record time, location, and staff present.

2. **Image / backup (forensics-first)**

   * If allowed and feasible, create a full device image or at least a complete user-data backup. If a full forensic image is not allowed, capture:

     * `/sdcard` contents,
     * app APKs (if available),
     * screenshots of home screens and installed apps,
     * system settings pages (Android version, Build number, Developer Options page if it exists),
     * `About phone` page (model, build, security patch).
   * Store image/backup on secure storage; compute integrity hash (SHA256).

3. **Check & set initial settings (only if allowed by rules)**

   * Check if Developer Options exists and whether **USB Debugging** is ON or OFF. Record state.
   * Check whether Play Protect and any vendor antivirus/security apps are active. Record.
   * Check Wi-Fi status: connect to lab VLAN / make sure phone is isolated (or note if already connected to public network).
   * If permitted by scope and you intend to use ADB: enable Developer Options and USB Debugging **now** (this is the single best leverage for remote control). If you must ask examiners to enable it, do so and document it.

4. **One-time setup options (choose per rules & objective)**

   * **If you can enable USB Debugging:** enable it, then (recommended) enable ADB TCPIP or install a small signed test app that re-enables ADB or opens a reverse channel (install only your benign app that you control). This sets up future remote access after you leave.
   * **If you can only install but not change settings:** install a signed test APK that requests the minimal permissions needed (ACCESS_NETWORK_STATE, INTERNET, RECEIVE_BOOT_COMPLETED if allowed) and be transparent in report. Make sure app auto-start option is set if allowed.
   * **If you cannot change anything:** collect as much passive intel as possible (installed apps list, versions, versions of Play Protect) and exit — your later options will be limited to non-physical attacks (network MITM, API fuzzing if you can get the device to use your proxy).

**Important:** Every change you make must be recorded (timestamp, purpose, and proof). If you alter the device (enable dev options, install app), take a clear before/after screenshot.

---

## 4 — Initial verification & imaging (deep)

* **Imaging priority:** full image > partition dumps > file-level backups. If full image impossible, capture:

  * Screenshots of each Settings page you interact with,
  * A DB dump of app data you can access,
  * Exported APKs (if possible),
  * `adb logcat` if debugging is enabled (capture logs),
  * Packet capture (Wireshark/tcpdump) during initial baseline interactions.
* **Chain of custody:** keep a log of who touched device, timestamps, actions, and where backups are stored. This is part of professional reporting and exam grading.

---

## 5 — Network isolation & baseline captures

* Place device on lab VLAN/isolated Wi-Fi. Assign known IP.
* Start passive packet capture on VLAN (Wireshark/tcpdump) to record DNS, HTTP(S) endpoints used by apps. This gives you later context for API analysis.
* Observe app behavior without interacting (open app and record traffic). You’ll get clues about servers, API paths, and whether traffic is encrypted.

---

## 6 — Core workflows (high level — what to do next)

### A) Reconnaissance (local + network)

* Inventory installed apps and versions. Identify suspicious or privileged apps.
* Note debuggable apps (manifest flag) and exported components (activities/services/receivers/providers).
* Find apps signed with test keys or old debug builds.
* Map network endpoints the device communicates with — identify plain HTTP or weak TLS.

### B) Static analysis (APK-level)

* Extract APKs (from `/data/app` if possible or downloaded from backup). Run an offline analyzer (MobSF) and human-review with jadx/apktool. Look for:

  * Hardcoded keys, endpoints, credentials,
  * Exported components with `exported="true"`,
  * Intents that accept external input,
  * Insecure storage usage (plain text files, insecure DBs),
  * Certificate pinning implementation (strings hinting at pinning).

### C) Dynamic analysis (runtime)

* Use Burp Suite + device to proxy app traffic (install Burp CA on device). Intercept and analyze API calls, tokens, cookie handling, weak auth, and insecure endpoints.
* Use Frida/Objection to hook functions: find token handling, bypass logic checks, dump runtime strings. Use emulator first to refine scripts, then target device if permitted.

### D) Access methods (choose one based on initial state)

1. **ADB / scrcpy (best-case / most straightforward)** — if USB debugging enabled:

   * Connect via USB first to confirm access; if allowed, enable ADB-over-TCP for remote reconnection.
   * Use scrcpy for live screen and input control; use `adb shell` for file operations, logcat, and app control.
2. **Controlled test APK (recommended for persistence demo)** — create and install a benign app you control that:

   * Uses a reverse TLS socket or web socket to your lab server (purely demonstration, no exfiltration of real data),
   * Optionally starts on boot (RECEIVE_BOOT_COMPLETED),
   * Uses minimal permissions.
   * Install only on devices you explicitly control/are allowed to modify.
3. **Exploit app vulnerabilities** (only when explicitly allowed and you have technical proof): insecure exported components, weak IPC, insecure file permissions, etc. These are often the only route if debugging is disabled and no app install is permitted.
4. **Network attacks** — intercept and manipulate traffic (MITM) to cause the device to download a test APK or reveal sensitive endpoints (only in lab with permission).
5. **Root / system compromise** — only if explicitly allowed and documented. Rooting changes device state significantly and may invalidate forensic results; show conceptual approach and only perform if in scope.

### E) Post-access: data collection & proof

* Collect only authorized data: screenshots, logs, app DBs, relevant files from external storage.
* Save network captures showing API calls with sensitive parameters.
* For each artifact, note exact timestamps, method used, and how you validated it (hashes/screenshots).

---

## 7 — Tools — free → alternate → premium (what each does & when to use)

> **Priority order** for learning and exam prep is at top of each list.

### Core free tools (learn these first)

* **ADB (Android Debug Bridge)** — device shell, file pull/push, app install/uninstall, logs, port forwarding. (Use: baseline, access, file/data collection.)
* **scrcpy** — screen mirroring & remote control (USB / TCP). (Use: live demo of access.)
* **MobSF (Mobile Security Framework)** — automated static + dynamic scanning of APKs. (Use: fast vulnerability discovery.)
* **jadx** — decompile APK to Java-like source to find sensitive strings & logic. (Use: static analysis.)
* **apktool** — unpack/repack APKs, view manifest, resources, and smali. (Use: deeper static work & proof-of-concept modifications in emulator.)
* **Frida + frida-tools** — dynamic instrumentation and function hooking at runtime. (Use: bypass protections, dump secrets at runtime.)
* **Objection** (uses Frida) — higher-level runtime exploration toolkit for mobile (bypass root checks, explore app file system).
* **Burp Suite Community** — intercept and analyze HTTP(S) app traffic (use with device CA).
* **Wireshark / tcpdump** — capture/analyze network packets.
* **Android Studio / Genymotion** — emulators for safe testing and reproducing issues.
* **DB Browser for SQLite** — view app SQLite DBs pulled from device.
* **Open-source forensic tools** (Autopsy / Sleuth Kit) — analyze images (if allowed).

### Alternate free tools (useful)

* **mitmproxy** — alternative to Burp for intercepting app traffic (CLI + web UI).
* **APK Inspector / Bytecode Viewer** — alternative decompilers and static analysis helpers.
* **NetHunter / Kali Nethunter** — mobile pentest platform (for advanced mobile-to-mobile testing).
* **adb backup / fastboot** — various backup/flash tools (availability depends on device & OEM).

### Premium / commercial tools (powerful; note cost & ethics)

* **Cellebrite UFED / Magnet AXIOM** — professional mobile forensic toolkits to extract deep data (often used by labs/law-enforcement).
* **Frida Pro / commercial Frida tooling wrappers** — enterprise-level instrumentation.
* **Burp Suite Professional** — advanced scanning, repeater enhancements, Intruder for fuzzing.
* **Mobile security testing suites** (AppSweep, NowSecure, Veracode) — commercial analysis.
* **Commercial forensics suites** for deep NAND / chip-off analysis.
* **Magisk (root)** — not premium but advanced; enables systemless root & module persistence (use only in-scope).

**Note:** Premium tools can make some tasks trivial (full extractions, bypasses) but are rarely permitted in student labs and can be costly. Know them conceptually and mention them in remediation if your report needs to recommend professional investigation.

---

## 8 — Developer Options / USB Debugging is OFF — what to do (realistic options)

You have one physical touch at start. If Developer Options is **OFF** and you **are allowed to change settings**, enable Developer Options → USB Debugging immediately. If you are **not allowed** to change settings — follow these tactics:

### If you can touch and change settings (best case)

* Enable Developer Options → enable USB Debugging → connect via ADB over USB to perform imaging and optionally enable ADB-over-TCP or install your test app for persistence.

### If you can touch but must not alter system settings permanently

* Use your single touch to **install a benign test APK** that only requests minimal permissions and is transparent. It can request `INTERNET` and optionally `RECEIVE_BOOT_COMPLETED`. **Do not enable USB Debugging** unless allowed. This lets you maintain a remote channel without flipping system-wide settings.

### If you cannot change settings and cannot install apps

* Rely on **passive & indirect vectors**:

  * **Network-based** — intercept the device’s traffic (if you can make the device connect through your proxy/VLAN) to discover endpoints and API weaknesses; then attempt to trigger a remote app update or social-engineer user into installing a test app (if allowed).
  * **Exploit exported components** — static analysis of apps (if you can obtain their APKs from Play Store or backup) to find IPC entry points that accept external intents and can be abused to extract data or cause actions. This often requires a crafted app or intent invocation.
  * **Use UI interactions** — if allowed during exam, you may be able to demonstrate that a user action (clicking a link, opening an infected content) leads to an exploit. In many exams, demonstrating the required user action is acceptable.

**Bottom line:** If debugging is OFF and you can’t change it, you likely cannot use ADB/scrcpy. Focus on APK/static analysis, network interception, and demonstrating feasible attack paths that require user interaction.

---

## 9 — Reboot, power-off, and persistence realities

* **Live session (scrcpy/ADB) dies on power-off/reboot.** Unless persistence was installed prior, you will lose remote sessions.
* **ADB-over-TCP is usually disabled after reboot**; re-setup often needs physical access unless an installed app re-enables it (requires special permissions/root).
* **File-based encryption & direct-boot:** some app data is only available after the user unlocks the device post-boot. That means even persistent agents may not access all private data until a user unlocks the phone.
* **Persistence options (lab-allowed):**

  * Install app that registers for `BOOT_COMPLETED` and opens a connection after unlock (note: will often need user-interaction to grant permissions on modern Android).
  * System-level persistence (root, Magisk module) — powerful but invasive and often out-of-scope for exams.
  * Accessibility-service based persistence (dangerous and detectable) — often flagged by Play Protect; avoid unless explicitly allowed.

---

## 10 — What you can / cannot access (practical realities)

* **You can typically access:**

  * External storage (photos, downloads) if not encrypted or if ADB allows access.
  * Logs if Developer Options enabled (`logcat`).
ta/data/...`) of non-debuggable apps without root.
  * Hardware-rooted key material (keystore with hardware-backed keys).
  * Encrypted app data until the phone is unlocked (post-boot).
  * Data protected by secure enclave / TEE in many banking apps.

---

## 11 — Data collection, evidence & reporting (deliverables)

**Deliverables the graders will expect**

1. **Authorization copy** (signed).
2. **Initial image/backup** with integrity hash and timestamp (before changes).
3. **Timeline / Activity log**: every command/action you performed, with timestamps.
4. **Proof-of-access artifacts**: screenshots, screen recordings (with time), `logcat` snippets, packet capture files, APKs you analyzed, and relevant database extracts.
5. **Vulnerability findings**: each finding should have:

   * Title (e.g., “Exported Activity allows unauthenticated content injection”),
   * Impact (what an attacker could do),
   * Evidence (screenshots, code lines, Burp request/response),
   * Repro steps (high-level only — do not include exploit code unless allowed),
   * Severity rating and remediation advice.
6. **Cleanup proof**: screenshots/notes showing app uninstalled or device restored to original image.
7. **Executive summary**: non-technical summary of risk and top 3 remediations.

---

## 12 — Cleanup & restore checklist (must show)

* Uninstall any test apps you installed (take screenshots).
* Disable any debug settings you enabled (return to prior state) unless lab rules say to leave as-is.
* Restore device from original image or factory reset as required by lab.
* Hand over signed report and backup images/hashes to lab pro.
* Provide step-by-step cleanup log (who did what, when).

---

## 13 — Practical pentester tips & exam-winning behaviours

* **Forensics-first mindset** — image before anything else. Examiners love this.
* **Document every interaction** — timestamps are gold. If you show you can’t do something (e.g., Play Protect prevented install), that’s a valid finding — show the proof.
* **Use emulators to test everything first** — scripts, Frida hooks, Burp intercepts — so your live run is smooth.
* **Show multiple approaches** — if ADB works, still show static analysis findings and a Burp capture to demonstrate depth. Variety = stronger result.
* **Explain limitations openly** — e.g., “I could not access `/data/data` because the app is not debuggable and device is not rooted.” This shows you understand OS protections.
* **Be conservative with persistence** — lab instructors prefer controlled benign apps; avoid root unless allowed.
* **Bring a short demo script** — 3 points to show in 10 minutes: baseline evidence, one exploit/demo, cleanup. Practice this demo.

---

## 14 — 60-second exam starter checklist (CHEAT-SHEET)

When you first touch the device, do these in 60 seconds:

1. Photograph device and serial/IMEI.
2. Note Android version & patch level (Settings → About).
3. Check & record Developer Options status and USB Debugging state.
4. Check Play Protect / vendor security status.
5. Put phone on isolated lab Wi-Fi (or confirm isolated).
6. Create immediate backup/image or at minimum capture screenshots of key screens.
7. Start packet capture on lab VLAN (Wireshark/tcpdump) and note device IP.
8. If allowed, enable USB Debugging and connect ADB to confirm visibility.

---

## 15 — Appendix — Example test plan & findings structure (what to hand in)

**Example Test Plan (one page)**

* Objective: Demonstrate ability to access an authorized Android 11 device, find and report vulnerabilities, demonstrate safe persistence, and restore device.
* Scope: Device model X, Android 11, lab VLAN, non-destructive testing.
* Tools: ADB, scrcpy, MobSF, jadx, Apktool, Frida, Burp, Wireshark, SQLite Browser.
* Steps: Image → Isolate → Recon → Static Analysis → Dynamic Analysis → Access Demo → Evidence Collection → Cleanup → Report.

**Example Finding (template)**

* Title: Insecure Transport — Token sent in cleartext.
* Severity: High
* Evidence: Burp request/response capture (screenshot), packet capture (pcap), API endpoint.
* Impact: Credentials/tokens could be intercepted on untrusted networks.
* Repro Steps (high-level): Intercept app request via lab proxy → observe token.
* Recommendation: Enforce TLS and server-side token rotation; implement certificate pinning.
* Status: Demo’ed during lab on 2025-10-31 10:40 (UTC+5) — see pcap `capture1.pcap`.

---

## Final notes — things you must memorize

* **Image-first** (always).
* **Document everything** (timestamps, screenshots).
* **If Dev Options ON → use ADB / scrcpy** (fastest path to access).
* **If Dev Options OFF→ install a benign test app if allowed OR rely on network/inter-app flaws**.
* **Reboot kills live sessions** unless a permitted persistent agent is present.
* **Most protected data requires root or post-unlock state**; explain these limits in your report.
